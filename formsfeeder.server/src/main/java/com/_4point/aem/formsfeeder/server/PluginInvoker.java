package com._4point.aem.formsfeeder.server;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Supplier;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;

import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com._4point.aem.formsfeeder.core.api.FeedConsumer;
import com._4point.aem.formsfeeder.core.api.FeedConsumer.FeedConsumerBadRequestException;
import com._4point.aem.formsfeeder.core.api.FeedConsumer.FeedConsumerException;
import com._4point.aem.formsfeeder.core.api.FeedConsumer.FeedConsumerInternalErrorException;
import com._4point.aem.formsfeeder.core.datasource.DataSource;
import com._4point.aem.formsfeeder.core.datasource.DataSourceList;
import com._4point.aem.formsfeeder.core.datasource.StandardMimeTypes;
import com._4point.aem.formsfeeder.server.PluginInvoker.ResponseData;
import com._4point.aem.formsfeeder.server.pf4j.FeedConsumers;
import com._4point.aem.formsfeeder.server.support.CorrelationId;
import com._4point.aem.formsfeeder.server.support.DataSourceListJaxRsUtils;

/**
 * @author rob.mcdougall
 *
 */
@Component
public class PluginInvoker {

	// Prefix used on DataSource names generated by fluentforms.  This is to make sure that they do not clash with
	// names provided by user applications.  Users should avoid using this prefix.
	public static final String FORMSFEEDER_PREFIX = "formsfeeder:";
	private static final String REDIRECT_LOCATION_DS_NAME = FORMSFEEDER_PREFIX + "RedirectLocation";

	// Path that all plug-in services reside under.
	/* package */ static final String API_V1_PATH = "/api/v1";

	private final FeedConsumers feedConsumers;

	@Autowired
	public PluginInvoker(FeedConsumers feedConsumers) {
		super();
		this.feedConsumers = feedConsumers;
	}

	/**
	 * This interface is used by other classes that convert DataSourceLists into a compound Response.
	 * It exists in order to allow the code that converts this to a JAX-RS Response object to live
	 * here in a central location.   
	 *
	 */
	protected static interface ResponseData {
		public Object data();
		public MediaType mediaType();
	}

	/**
	 * Determines if there is a plug-in associated with an Url provided and, if so, then invokes that plug-in.  Also
	 * captures any exceptions that a plugin throws and converts it to a response.
	 * 
	 * We're intentionally sparse in the information about exceptions that we return to the client for security reasons.
	 * We just pass back the exception message.  Full details (and a stack trace) are written to the log.  That's where
	 * someone should go in order to get a fuller picture of what the issue is.
	 * 
	 * @param consumerName  Name of the consumer (i.e. plugin) to invoke.
	 * @param dataSourceList  DataSources that are the inputs to the consumer (i.e plugin)
	 * @param logger   Logger for method to log to.
	 * @return
	 * @throws PluginInvokerPluginNotFoundException 
	 * @throws PluginInvokerInternalErrorException 
	 * @throws PluginInvokerBadRequestException 
	 */
	protected final DataSourceList invokePlugin(final String consumerName, final DataSourceList dataSourceList, final Logger logger) throws PluginInvokerPluginNotFoundException, PluginInvokerInternalErrorException, PluginInvokerBadRequestException {
		Optional<FeedConsumer> optConsumer = feedConsumers.consumer(consumerName);
		if (optConsumer.isEmpty()) {
			String msg = "Resource '" + API_V1_PATH + "/" + consumerName + "' does not exist.";
			throw new PluginInvokerPluginNotFoundException(msg);
		} else {
			try {
				return invokeConsumer(dataSourceList, optConsumer.get(), logger);
			} catch (FeedConsumerInternalErrorException e) {
				String msg = String.format("Plugin processor experienced an Internal Server Error. (%s)", e.getMessage());
				throw new PluginInvokerInternalErrorException(msg, e);
			} catch (FeedConsumerBadRequestException e) {
				String msg = String.format("Plugin processor detected Bad Request. (%s)", e.getMessage());
				throw new PluginInvokerBadRequestException(msg, e);
			} catch (FeedConsumerException e) {
				String msg = String.format("Plugin processor error. (%s)", e.getMessage());
				throw new PluginInvokerInternalErrorException(msg, e);
			} catch (Exception e) {
				String msg = String.format("Error within Plugin processor. (%s)", e.getMessage());
				throw new PluginInvokerInternalErrorException(msg, e);
			}
		}
	}
	
	/**
	 * Invokes a FeedConsumer provided by a plug-in.
	 * 
	 * @param inputs  List of DataSources will be used as inputs to the FeedConsumer.
	 * @param consumer FeedConsumer (i.e. plugin) to invoke
	 * @param logger  Logger for method to log to.
	 * @return
	 * @throws FeedConsumerException
	 */
	private static final DataSourceList invokeConsumer(final DataSourceList inputs, final FeedConsumer consumer, final Logger logger) throws FeedConsumerException {
		logger.debug("Before calling Plugin");
		DataSourceList accept = consumer.accept(inputs);
		logger.debug("After calling Plugin");
		return accept;
	}
	
	// The next few public static routines are helper functions that are typically used by classes that utilize the
	// pluginInvoker object.
	
	/**
	 * Converts the DataSourceList returned by a plug-in to a Response that will get sent back to the caller
	 * 
	 * @param outputs  List of DataSources that will be returned in the Response.
	 * @param logger   Logger for method to log to.
	 * @param multiReturnConverter  Function for converting multiple DataSources into a single Response.  Can be null when multiple DataSource responses is not allowed (for example, when processing a submission).
	 * @return
	 */
	public static final ResponseBuilder convertToResponseBuilder(final DataSourceList outputs, final Logger logger, final BiFunction<DataSourceList, Logger, ResponseBuilder> multiReturnConverter, final Supplier<ResponseBuilder> emptyResponseFn) {
		try {
			List<DataSource> dsList = Objects.requireNonNull(outputs, "Plugin returned null DataSourceList!").list();
			if (dsList.isEmpty()) {
				// Nothing in the response, so return no content.
				logger.debug("No data sources were returned from the plugin.");
				return emptyResponseFn.get();
			} else if (dsList.size() == 1 && !dsList.get(0).contentType().equals(StandardMimeTypes.APPLICATION_VND_4POINT_DATASOURCELIST_TYPE)) {
				final DataSource dataSource = dsList.get(0);
				logger.debug("One data source was returned from the plugin (" + dataSource.name() + ").");
				Optional<String> redirectUrl = outputs.deconstructor().getStringByName(REDIRECT_LOCATION_DS_NAME);
				if (redirectUrl.isPresent()) {
					// The plugin is asking for a redirect.
					return Response.seeOther(new URI(redirectUrl.get()));
				} else {
					// One data source that is not a DataSourceList and not a redirect, so return the contents in the body of the response.
					return DataSourceListJaxRsUtils.asResponseBuilder(dataSource, logger);
				}
			} else { // More than one return or a single DataSourceList return.
				logger.debug(outputs.size() + " data sources were returned from the plugin.");
				return multiReturnConverter.apply(outputs, logger);
			}
		} catch (URISyntaxException e) {
			throw new IllegalArgumentException("Invalid Redirect URI returned from plugin.",e);
		}
	}

	/**
	 * Helper function that converts a DataSource List into compound response (given a function that converts that DataSourceList into a
	 * Response Data object.
	 * 
	 * @param dataSources
	 * @param logger
	 * @param multiReturnConverter
	 * @return
	 */
	public static ResponseBuilder multipleDsHandler(DataSourceList dataSources, Logger logger, final BiFunction<DataSourceList, Logger, ResponseData> multiReturnConverter) {
		ResponseData responsesData = Objects.requireNonNull(multiReturnConverter, "Multiple Returns not supported for this type of request.").apply(dataSources, logger);
		return Response.ok(responsesData.data(), responsesData.mediaType());
	}
	
	/**
	 * Build a response from a ResponseBuilder.  This is mainly to make sure that all responses contain the correlationId in them.
	 * 
	 * @param builder
	 * @param correlationId
	 * @return
	 */
	public static final Response buildResponse(final ResponseBuilder builder, final String correlationId) {
		builder.header(CorrelationId.CORRELATION_ID_HDR, correlationId);
		return builder.build();
	}
	

	@SuppressWarnings("serial")
	public static class PluginInvokerBadRequestException extends Exception {

		public PluginInvokerBadRequestException() {
		}

		public PluginInvokerBadRequestException(String message) {
			super(message);
		}

		public PluginInvokerBadRequestException(Throwable cause) {
			super(cause);
		}

		public PluginInvokerBadRequestException(String message, Throwable cause) {
			super(message, cause);
		}

	}

	@SuppressWarnings("serial")
	public static class PluginInvokerInternalErrorException extends Exception {

		public PluginInvokerInternalErrorException() {
		}

		public PluginInvokerInternalErrorException(String message) {
			super(message);
		}

		public PluginInvokerInternalErrorException(Throwable cause) {
			super(cause);
		}

		public PluginInvokerInternalErrorException(String message, Throwable cause) {
			super(message, cause);
		}

	}

	@SuppressWarnings("serial")
	public static class PluginInvokerPluginNotFoundException extends Exception {

		public PluginInvokerPluginNotFoundException() {
		}

		public PluginInvokerPluginNotFoundException(String message) {
			super(message);
		}

		public PluginInvokerPluginNotFoundException(Throwable cause) {
			super(cause);
		}

		public PluginInvokerPluginNotFoundException(String message, Throwable cause) {
			super(message, cause);
		}

	}
}
